<h1 id="extract">Extract</h1>
<p>'Extract' is a command line tool for extracting SQL and other code from marked up text files that are able to represent pre-formated text sections.</p>
<p>Currently, two such text formats are explicitly supported - Markdown and MaxText. MaxText is a plain text markup system that is similar conceptually to Markdown.</p>
<p>Markdown uses a triplet of back-ticks (&quot;```&quot;) in the left-most column to indicate the start and end of a pre-formatted text section, while Maxtext uses a tilde ('~') character. While, technically, both text systems ignore any remaining text on the line, some systems such as Github, allow remaining text to hint at a programming language, and others such as Pandoc may not recognise the delimiter if there are spaces in any remaining text.</p>
<p>'Extract' uses these superfluous characters to indicate a pattern that will be matched against a pattern passed as a common-line argument. For example, when run, the following command line matches pre-formatted sections in the specified files that contain the pattern 'tables'.</p>
<pre><code>extract -p &quot;tables&quot; source/mt/file.txt &gt; sql/tables.sql</code></pre>
<p>When using Markdown, such a pre-formatted block would be delimited as such:</p>
<pre><code> ```tables
 Pre-formatted text here</code></pre>
<p>Unfortunately, it seems like there is no pattern that can be used with both Pandoc and Github to indicate both a pattern and a file type. For example, Github will accept a delimiter such as that below and appropriately mark it up as SQL:</p>
<pre><code> ```tables sql</code></pre>
<p>However, Pandoc does not seem to accept such a delimiter, but rather will accept the following, which is not accepted by Github:</p>
<pre><code> ```tables.sql</code></pre>
<p>Therefore, if you will only be using Github you can use a pattern that has a space then 'sql', however, if you will be using Pandoc, use a pattern with no spaces in it.</p>
<p>Hopefully, in the future one of these two systems will be modified so that they can support similar patterns.</p>
<h2 id="implementation">Implementation</h2>
<p>The following sections describe the current implementation of 'Extract'. This implementation now uses the &quot;quasi-literate programming&quot; style as described at: [https://www.quasi-literateprogramming.org]. To facilitate this implementation that now supports Markdown, the tool 'quasi' was also extended to support Markdown.</p>
<p>Source code extracted from this file may be viewed under the '_gen' directory.</p>
<div class="sourceCode"><pre class="sourceCode !main.c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> *  !!! This document has been auto-generated using quasi !!!</span>
<span class="co"> */</span></code></pre></div>
<h3 id="dependencies">Dependencies</h3>
<p>'Extract' depends on functions declared in the following header files.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></code></pre></div>
<p>This header is included to provide access to the 'calloc' and 'free' functions: 'calloc' is used to allocate memory that has been zeroed, while 'free' is used to deallocate allocated memory.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></code></pre></div>
<p>This header is included to provide access to the 'fopen', 'fclose', and 'fprintf' functions: 'fopen' is used to open the files indicated by the command-line arguments, 'fclose' is used to close those files, and 'fprintf' is used to write pre-formatted text blocks to the standard output stream.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></code></pre></div>
<p>This header is included to provide access to the 'strdup', 'strcmp', 'strncmp', 'strlen', 'strpcpy', and functions: 'strdup' is used to duplicate the passed string, 'strcmp' and 'strncmp' are used to compare whether two strings are equal ('strcmp'), or whether one is a prefix of the other ('strncmp'). 'strlen' is used to find the length of a string, and 'strpcpy' is used to ???</p>
<h3 id="defined-types-and-values">Defined types and values</h3>
<p>The 'int' type is typecast to a 'bool' for readability.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> bool;</code></pre></div>
<h3 id="global-state">Global state</h3>
<p>The implementation has two global variables: if 'DEBUG' is set to 'TRUE', extra debugging lines are output to the standard error stream. if 'STRIP' is set to 'TRUE', extract will strip lines beginning with 'DELIMITER' from the ouput.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">static</span> bool DEBUG = <span class="dv">0</span>;
<span class="dt">static</span> bool STRIP = <span class="dv">0</span>;</code></pre></div>
<h3 id="high-level-function-structure">High-level function structure</h3>
<pre><code>int    argumentsContains();
char*  argumentsGetValue();
int                usage();
char*    generatePattern( const char* );
void        tryToProcess( char*, const char* );
void             process( FILE*, const char* );
char*           readline( FILE* );
void processPreformatted( char* line, FILE*, const char* pattern );</code></pre>
<pre><code>int main( int argc, char** files )
{
    STRIP     = argumentsContains( argc, files, &quot;-s&quot; ) ? 1 : 0;
    char* pat = argumentsGetValue( argc, files, &quot;-p&quot; );

    int expected_arguments = 4 + STRIP; // extract -p &quot;some pattern&quot; files [-s]

    if ( ! pat )
    {
        return usage();
    }
    else
    if ( argc &lt; expected_arguments )
    {
        return usage();
    }
    else
    {
        char* pattern = generatePattern( pat );
        int i;
        for ( i=expected_arguments; i &lt; argc; i++ )
        {
            tryToProcess( files[i], pattern );
        }

        free( pattern );
    }
    free( pat );

    return 0;
}</code></pre>
<pre><code>int argumentsContains( int n, char** files, char* flag )
{
    int b = 0;
    int i;

    for ( i=0; i &lt; n; i++ )
    {
        if ( stringEquals( flag, files[i] ) )
        {
            b = 1;
            i = n;
        }
    }
    return b;
}</code></pre>
<pre><code>char* argumentsGetValue( int n, char** files, char* flag )
{
    char* ret = NULL;
    int i;

    for ( i=0; i &lt; n; i++ )
    {
        if ( stringEquals( flag, files[i] ) )
        {
            i++;
            if ( i &lt; n) ret = strdup( files[i] );
            i = n;
        }
    }
    return ret;
}</code></pre>
<pre><code>int stringEquals( const char* one, const char* two )
{
    return (0 == strcmp( one, two ));
}</code></pre>
<pre><code>int usage()
{
    fprintf( stderr, &quot;Usage:\n\textract [-s] -p &lt;pattern&gt; &lt;file&gt; [more files] [ &gt; output file ]\n&quot; );
    return -1;
}</code></pre>
<pre><code>char* generatePattern( const char* pat )
{
    int len = strlen( pat );
    char* pattern = calloc( len + 3, sizeof(char) );
    char* tmp = pattern;
    tmp = stpcpy( tmp, &quot;~&quot; );
    tmp = stpcpy( tmp, pat );
    tmp = stpcpy( tmp, &quot;~&quot; );
    return pattern;
}</code></pre>
<pre><code>void tryToProcess( char* file, const char* pattern )
{
    FILE* stream;
    if ( (stream = fopen( file, &quot;r&quot; )) )
    {
        if ( DEBUG ) fprintf( stderr, &quot;Processing: %s\n&quot;, file );
        process( stream, pattern );
        fclose( stream );
    }
}</code></pre>
<pre><code>void process( FILE* stream, const char* pattern )
{
    char* line;
    do
    {
        line = readline( stream );
        if ( line )
        {
            switch ( line[0] )
            {
            case &#39;~&#39;:
                if ( DEBUG ) fprintf( stderr, &quot;@%s&quot;, line );
                processPreformatted( line, stream, pattern );
                break;
            default:
                if ( DEBUG ) fprintf( stderr, &quot;@%s&quot;, line );
            }
            free( line );
        }
    } while ( line );
}</code></pre>
<pre><code>void processPreformatted( char* line, FILE* stream, const char* pattern )
{
    int   loop = 1;
    char* pre;

    FILE* out  = stderr;
    char* c    = &quot;@&quot;;

    if ( 0 == strncmp( pattern, line, strlen(pattern) ) )
    {
        out = stdout;
        c   = &quot;&quot;;
    }

    do
    {
        pre = readline( stream );
        if ( pre )
        {
            if ( STRIP )
            {
                switch ( pre[0] )
                {
                case &#39;~&#39;:
                    if ( DEBUG ) fprintf( stderr, &quot;@%s&quot;, pre );
                    loop = 0;
                    break;
                case &#39;/&#39;:
                    if ( &#39;/&#39; == pre[1] ) fprintf( out, &quot;;\n&quot; );
                    break;
                case &#39;D&#39;:
                case &#39;d&#39;:
                    if ( 0 == strncmp( &quot;DROP&quot;,      pre, strlen( &quot;DROP&quot;      ) ) ) break;
                    if ( 0 == strncmp( &quot;drop&quot;,      pre, strlen( &quot;drop&quot;      ) ) ) break;
                    if ( 0 == strncmp( &quot;DELIMITER&quot;, pre, strlen( &quot;DELIMITER&quot; ) ) ) break;
                    if ( 0 == strncmp( &quot;delimiter&quot;, pre, strlen( &quot;delimiter&quot; ) ) ) break;
                default:
                    if ( 0 != strncmp( &quot;@&quot;, c, 1 ) ) fprintf( out, &quot;%s%s&quot;, c, pre );
                }
            }
            else
            {
                switch ( pre[0] )
                {
                case &#39;~&#39;:
                    if ( DEBUG ) fprintf( stderr, &quot;@%s&quot;, pre );
                    loop = 0;
                    break;
                case &#39;D&#39;:
                case &#39;d&#39;:
                    if ( 0 == strncmp( &quot;DROP&quot;,      pre, strlen( &quot;DROP&quot;      ) ) ) break;
                    if ( 0 == strncmp( &quot;drop&quot;,      pre, strlen( &quot;drop&quot;      ) ) ) break;
                    if ( 0 == strncmp( &quot;delimiter&quot;, pre, strlen( &quot;delimiter&quot; ) ) ) break;
                default:
                    if ( 0 != strncmp( &quot;@&quot;, c, 1 ) ) fprintf( out, &quot;%s%s&quot;, c, pre );
                }
            }
            free( pre );
        } else {
            loop = 0;
        }
    }
    while ( loop );
}</code></pre>
<pre><code>char* readline( FILE* stream )
{
    int   n = 0;
    char* line = calloc( 1024, sizeof(char) );
    char* ptr  = calloc( 10,  sizeof(char) );
    int read;
    do
    {
        read = fread( ptr, sizeof(char), 1, stream );
        if ( read )
        {
            switch( *ptr )
            {
            case &#39;\n&#39;:
                line[n++] = *ptr;
                read = 0;
                break;
            default:
                line[n++] = *ptr;
            }
        }
    } while ( 0 != read );
    free( ptr );

    if ( n )
    {
        return line;
    }
    else
    {
        free( line );
        return NULL;
    }
}</code></pre>
