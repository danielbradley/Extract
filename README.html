<h1 id="extract">Extract</h1>
<p>'Extract' is a command line tool for extracting SQL and other code from marked up text files that are able to represent pre-formated text sections.</p>
<p>Currently, two such text formats are explicitly supported - Markdown and MaxText. MaxText is a plain text markup system that is similar conceptually to Markdown.</p>
<p>Markdown uses a triplet of back-ticks (&quot;```&quot;) in the left-most column to indicate the start and end of a pre-formatted text section, while Maxtext uses a tilde ('~') character. While, technically, both text systems ignore any remaining text on the line, some systems such as Github, allow remaining text to hint at a programming language, and others such as Pandoc may not recognise the delimiter if there are spaces in any remaining text.</p>
<p>'Extract' uses these superfluous characters to indicate a pattern that will be matched against a pattern passed as a common-line argument. For example, when run, the following command line matches pre-formatted sections in the specified files that contain the pattern 'tables'.</p>
<pre><code>extract -p &quot;tables&quot; source/mt/file.txt &gt; sql/tables.sql</code></pre>
<p>When using Markdown, such a pre-formatted block would be delimited as such:</p>
<pre><code> ```tables
 Pre-formatted text here</code></pre>
<p>Unfortunately, it seems like there is no pattern that can be used with both Pandoc and Github to indicate both a pattern and a file type. For example, Github will accept a delimiter such as that below and appropriately mark it up as SQL:</p>
<pre><code> ```tables sql</code></pre>
<p>However, Pandoc does not seem to accept such a delimiter, but rather will accept the following, which is not accepted by Github:</p>
<pre><code> ```tables.sql</code></pre>
<p>Therefore, if you will only be using Github you can use a pattern that has a space then 'sql', however, if you will be using Pandoc, use a pattern with no spaces in it.</p>
<p>Hopefully, in the future one of these two systems will be modified so that they can support similar patterns.</p>
<h2 id="implementation">Implementation</h2>
<p>The following sections describe the current implementation of 'Extract'. This implementation now uses the &quot;quasi-literate programming&quot; style as described at: [https://www.quasi-literateprogramming.org]. To facilitate this implementation that now supports Markdown, the tool 'quasi' was also extended to support Markdown.</p>
<p>Source code extracted from this file may be viewed under the '_gen' directory.</p>
<div class="sourceCode"><pre class="sourceCode !main.c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> *  !!! This document has been auto-generated using quasi !!!</span>
<span class="co"> */</span></code></pre></div>
<h3 id="dependencies">Dependencies</h3>
<p>'Extract' depends on functions declared in the following header files.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></code></pre></div>
<p>This header is included to provide access to the 'calloc' and 'free' functions: 'calloc' is used to allocate memory that has been zeroed, while 'free' is used to deallocate allocated memory.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></code></pre></div>
<p>This header is included to provide access to the 'fopen', 'fclose', and 'fprintf' functions: 'fopen' is used to open the files indicated by the command-line arguments, 'fclose' is used to close those files, and 'fprintf' is used to write pre-formatted text blocks to the standard output stream.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></code></pre></div>
<p>This header is included to provide access to the 'strdup', 'strcmp', 'strncmp', 'strlen', 'strpcpy', and functions: 'strdup' is used to duplicate the passed string, 'strcmp' and 'strncmp' are used to compare whether two strings are equal ('strcmp'), or whether one is a prefix of the other ('strncmp'). 'strlen' is used to find the length of a string, and 'strpcpy' is used to ???</p>
<h3 id="defined-types-and-values">Defined types and values</h3>
<p>The 'int' type is typecast to a 'bool' for readability.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> bool;</code></pre></div>
<h3 id="global-state">Global state</h3>
<p>The implementation has two global variables: if 'DEBUG' is set to 'TRUE', extra debugging lines are output to the standard error stream. if 'STRIP' is set to 'TRUE', extract will strip lines beginning with 'DELIMITER' from the ouput.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">static</span> bool DEBUG = FALSE;
<span class="dt">static</span> bool STRIP = FALSE;</code></pre></div>
<h3 id="high-level-function-structure">High-level function structure</h3>
<p>'Extract' has a simple call-graph, which is shown below:</p>
<pre><code>main
 |-- argumentsContains
 |-- argumentsGetValue
 |-- usage
 |-- generatePattern
 |-- tryToProcess
      |-- process
           |-- readline
           |-- processPreformatted</code></pre>
<p>An summary of these functions is given, then their implementation is discussed in detail.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv );</code></pre></div>
<p>The 'main' function is responsible for checking whether appropriate arguments have been passed and: if so, calling tryToProcess on each file and; if not, calling the 'usage' function.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c">bool argumentsContains( <span class="dt">int</span> argc, <span class="dt">char</span>** argv, <span class="dt">char</span>* flag );</code></pre></div>
<p>The 'argumentsContains' function check each of the arguments passed to main to see if it matches the specified flag.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">char</span>* argumentsGetValue( <span class="dt">int</span> n, <span class="dt">char</span>** files, <span class="dt">char</span>* flag )</code></pre></div>
<p>The 'argumentsGetValue' function retrieves (if appropriate) the value following a specific flag.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">int</span> usage();</code></pre></div>
<p>The 'usage' function simply prints out the usage string and always returns -1.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">char</span>* generatePattern( <span class="dt">const</span> <span class="dt">char</span>* pattern );</code></pre></div>
<p>The 'generate' pattern function is used to generate the line delimiter to be searched for in the input files.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">void</span> tryToProcess( <span class="dt">char</span>* file, <span class="dt">const</span> <span class="dt">char</span>* line_pattern );</code></pre></div>
<p>The 'tryToProcess' function tries to open the passed file, and if successful passes the opened stream to 'process' along with the passed line pattern.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">void</span> process( FILE*, <span class="dt">const</span> <span class="dt">char</span>* );</code></pre></div>
<p>The 'process' function reads each line of the passed stream, and if the passed line pattern is found outputs any further lines to standard output until an end delimiter is encountered.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">char</span>* readline( FILE* );</code></pre></div>
<p>The 'readline' function reimplements the UNIX readline function for portability.</p>
<div class="sourceCode"><pre class="sourceCode main.c"><code class="sourceCode c"><span class="dt">void</span> processPreformatted( <span class="dt">char</span>* line, FILE*, <span class="dt">const</span> <span class="dt">char</span>* pattern );</code></pre></div>
<p>The 'processPreformatted' function is used to strip out lines starting with specific keywords such as 'DELIMITER', or 'DROP', which (in the case of SQL) it is often desirous to remove for installation scripts.</p>
<h3 id="low-level-implemention-function-descriptions">Low-level implemention function descriptions</h3>
<h4 id="function-main">Function: main</h4>
<pre><code>int main( int argc, char** files )
{
    STRIP     = argumentsContains( argc, files, &quot;-s&quot; ) ? 1 : 0;
    char* pat = argumentsGetValue( argc, files, &quot;-p&quot; );

    int expected_arguments = 4 + STRIP; // extract -p &quot;some pattern&quot; files [-s]

    if ( ! pat )
    {
        return usage();
    }
    else
    if ( argc &lt; expected_arguments )
    {
        return usage();
    }
    else
    {
        char* pattern = generatePattern( pat );
        int i;
        for ( i=expected_arguments; i &lt; argc; i++ )
        {
            tryToProcess( files[i], pattern );
        }

        free( pattern );
    }
    free( pat );

    return 0;
}</code></pre>
<h4 id="function-argumentcontains">Function: argumentContains</h4>
<pre><code>int argumentsContains( int n, char** files, char* flag )
{
    int b = 0;
    int i;

    for ( i=0; i &lt; n; i++ )
    {
        if ( stringEquals( flag, files[i] ) )
        {
            b = 1;
            i = n;
        }
    }
    return b;
}</code></pre>
<h4 id="function-argumentgetvalue">Function: argumentGetValue</h4>
<pre><code>char* argumentsGetValue( int n, char** files, char* flag )
{
    char* ret = NULL;
    int i;

    for ( i=0; i &lt; n; i++ )
    {
        if ( stringEquals( flag, files[i] ) )
        {
            i++;
            if ( i &lt; n) ret = strdup( files[i] );
            i = n;
        }
    }
    return ret;
}</code></pre>
<h4 id="function-usage">Function: usage</h4>
<pre><code>int usage()
{
    fprintf( stderr, &quot;Usage:\n\textract [-s] -p &lt;pattern&gt; &lt;file&gt; [more files] [ &gt; output file ]\n&quot; );
    return -1;
}</code></pre>
<h4 id="function-generatepattern">Function: generatePattern</h4>
<pre><code>char* generatePattern( const char* pat )
{
    int len = strlen( pat );
    char* pattern = calloc( len + 3, sizeof(char) );
    char* tmp = pattern;
    tmp = stpcpy( tmp, &quot;~&quot; );
    tmp = stpcpy( tmp, pat );
    tmp = stpcpy( tmp, &quot;~&quot; );
    return pattern;
}</code></pre>
<h4 id="function-trytoprocess">Function: tryToProcess</h4>
<pre><code>void tryToProcess( char* file, const char* pattern )
{
    FILE* stream;
    if ( (stream = fopen( file, &quot;r&quot; )) )
    {
        if ( DEBUG ) fprintf( stderr, &quot;Processing: %s\n&quot;, file );
        process( stream, pattern );
        fclose( stream );
    }
}</code></pre>
<h4 id="function-process">Function: process</h4>
<pre><code>void process( FILE* stream, const char* pattern )
{
    char* line;
    do
    {
        line = readline( stream );
        if ( line )
        {
            switch ( line[0] )
            {
            case &#39;~&#39;:
                if ( DEBUG ) fprintf( stderr, &quot;@%s&quot;, line );
                processPreformatted( line, stream, pattern );
                break;
            default:
                if ( DEBUG ) fprintf( stderr, &quot;@%s&quot;, line );
            }
            free( line );
        }
    } while ( line );
}</code></pre>
<h4 id="function-processpreformatted">Function: processPreformatted</h4>
<pre><code>void processPreformatted( char* line, FILE* stream, const char* pattern )
{
    int   loop = 1;
    char* pre;

    FILE* out  = stderr;
    char* c    = &quot;@&quot;;

    if ( 0 == strncmp( pattern, line, strlen(pattern) ) )
    {
        out = stdout;
        c   = &quot;&quot;;
    }

    do
    {
        pre = readline( stream );
        if ( pre )
        {
            if ( STRIP )
            {
                switch ( pre[0] )
                {
                case &#39;~&#39;:
                    if ( DEBUG ) fprintf( stderr, &quot;@%s&quot;, pre );
                    loop = 0;
                    break;
                case &#39;/&#39;:
                    if ( &#39;/&#39; == pre[1] ) fprintf( out, &quot;;\n&quot; );
                    break;
                case &#39;D&#39;:
                case &#39;d&#39;:
                    if ( 0 == strncmp( &quot;DROP&quot;,      pre, strlen( &quot;DROP&quot;      ) ) ) break;
                    if ( 0 == strncmp( &quot;drop&quot;,      pre, strlen( &quot;drop&quot;      ) ) ) break;
                    if ( 0 == strncmp( &quot;DELIMITER&quot;, pre, strlen( &quot;DELIMITER&quot; ) ) ) break;
                    if ( 0 == strncmp( &quot;delimiter&quot;, pre, strlen( &quot;delimiter&quot; ) ) ) break;
                default:
                    if ( 0 != strncmp( &quot;@&quot;, c, 1 ) ) fprintf( out, &quot;%s%s&quot;, c, pre );
                }
            }
            else
            {
                switch ( pre[0] )
                {
                case &#39;~&#39;:
                    if ( DEBUG ) fprintf( stderr, &quot;@%s&quot;, pre );
                    loop = 0;
                    break;
                case &#39;D&#39;:
                case &#39;d&#39;:
                    if ( 0 == strncmp( &quot;DROP&quot;,      pre, strlen( &quot;DROP&quot;      ) ) ) break;
                    if ( 0 == strncmp( &quot;drop&quot;,      pre, strlen( &quot;drop&quot;      ) ) ) break;
                    if ( 0 == strncmp( &quot;delimiter&quot;, pre, strlen( &quot;delimiter&quot; ) ) ) break;
                default:
                    if ( 0 != strncmp( &quot;@&quot;, c, 1 ) ) fprintf( out, &quot;%s%s&quot;, c, pre );
                }
            }
            free( pre );
        } else {
            loop = 0;
        }
    }
    while ( loop );
}</code></pre>
<h4 id="function-readline">Function: readline</h4>
<pre><code>char* readline( FILE* stream )
{
    int   n = 0;
    char* line = calloc( 1024, sizeof(char) );
    char* ptr  = calloc( 10,  sizeof(char) );
    int read;
    do
    {
        read = fread( ptr, sizeof(char), 1, stream );
        if ( read )
        {
            switch( *ptr )
            {
            case &#39;\n&#39;:
                line[n++] = *ptr;
                read = 0;
                break;
            default:
                line[n++] = *ptr;
            }
        }
    } while ( 0 != read );
    free( ptr );

    if ( n )
    {
        return line;
    }
    else
    {
        free( line );
        return NULL;
    }
}</code></pre>
<h4 id="function-stringequals">Function: stringEquals</h4>
<pre><code>int stringEquals( const char* one, const char* two )
{
    return (0 == strcmp( one, two ));
}</code></pre>
<h4 id="function-stringhasprefix">Function: stringHasPrefix</h4>
<pre><code>int stringHasPrefix( const char* string, const char* prefix )
{
    int len = strlen( prefix )

    return (0 == strcmp( string, prefix, len ));
}</code></pre>
